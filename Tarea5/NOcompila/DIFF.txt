10a11,39
> /// Declaración genérica de la función 'random()'.
> template <class T> T* random();
> 
> #include <ctime>   // time_t
> #include <cstdlib> // malloc()
> 
> /// Especialización de 'random()' para el tipo 'char'.
> /// Es un truco para no tener que usar un archivo [.cpp]
> template<> char* random<char>() {
>     unsigned long ahora;
>     {   // http://stackoverflow.com/questions/997946/
>         time_t timev;
>         time(&timev);
>         ahora = 2 * static_cast<unsigned long>( timev ) % 3500;
>     }
> 
>     char * ret = 0; // NULL marca 'fallé'
>     while ( ret == 0 ) {
>         ahora /= 2; // por si falló el 'malloc()' anterior
>         ret = static_cast< char*> ( malloc( ahora ) );
>     }
> 
>     if ( ret==0 ) {
>         return const_cast< char* >( "CHANFLE" ); // malo MALO!
>         throw "CHANFLE"; // ???
>     }
>     return ret;
> }
> 
26,27c55,56
<     dejaHuecos( const & dejaHuecos OTRO ) m_num(OTRO.m_num), m_str(OTRO.m_str) {
<         ( static_cast< dejaHuecos* > ( &OTRO ) ) -> m_str = 0;
---
>     dejaHuecos( const dejaHuecos & OTRO ) : m_num(OTRO.m_num), m_str(OTRO.m_str) {
>         ( const_cast< dejaHuecos* > ( &OTRO ) ) -> m_str = 0;
31c60
<     dejaHuecos& operator=( const dejaHuecos & OTRO ) : m_num(OTRO.m_num), m_str(OTRO.m_str) {
---
>     dejaHuecos& operator=( const dejaHuecos & OTRO ) {
32a62
>         return *this;
43d72
< 
47,48c76,79
<     /// Obtiene ladel objeto.
<     void get( char * str ) { m_str = str; }
---
>     /// Obtiene la del objeto.
>     char* get() { return m_str; }
>     /// Obtiene la del objeto.
>     const char* get() const { return m_str; }
51,76d81
< /// Declaración genérica de la función 'random()'.
< template <T> T* random();
< 
< /// Especialización de 'random()' para el tipo 'char'.
< /// Es un truco para no tener que usar un archivo [.cpp]
< template <char>
< char* random<char>() {
<     unsigned long ahora;
<     {   // http://stackoverflow.com/questions/997946/
<         time_t timev;
<         time(&timev);
<         ahora = 2 * static_cast<unsigned long>( timev ) % 3500;
<     }
< 
<     char * ret = 0; // NULL marca 'falle'
<     while ( ret == 0 ) {
<         ahora /= 2; // por si falló el 'malloc()' anterior
<         ret = malloc( ahora );
<     }
< 
<     if ( ret==0 ) {
<         return static_cast< char*>( "CHANFLE" ); // malo MALO!
<         throw "CHANFLE"; // ???
<     }
< }
< 
11a12
> #include <cstring>       // strcmp()
24c25,26
< 
---
>         // Lo ejecuta varias veces para constatar que la
>         // memoria dinámica fue liberada adecuadamente
30c32
<                 std::list< dejaHuecos >::const_iterator last = Lhuecos.back();
---
>                 dejaHuecos & last = Lhuecos.back();
34,35c36
<                 if ( 0 == strcmp ( last->get(), Lhuecos.back() ) ) { break; }
<                 }
---
>                 if ( 0 == strcmp( last.get(), Lhuecos.back().get() ) ) { break; }
39c40
<             static char chanfle = { 'C','H','A','N','F','L','E',  \0 };
---
>             static char chanfle[] = { 'C','H','A','N','F','L','E', '\0'};
46a48
> 
